#!/usr/bin/env node

/**
 * SaaS Boilerplate Plugin CLI
 * 
 * Command-line interface for plugin development and management
 * Provides tools for creating, building, testing, and managing plugins
 */

import fs from 'fs/promises'
import path from 'path'

// Plugin CLI Configuration
const CLI_CONFIG = {
  name: 'saas-plugin',
  version: '1.0.0',
  description: 'SaaS Boilerplate Plugin Development CLI'
}

// =============================================================================
// PLUGIN TEMPLATES
// =============================================================================

const PLUGIN_TEMPLATES = {
  basic: {
    name: 'Basic Plugin',
    description: 'A basic plugin template with minimal structure',
    files: {
      'plugin.json': (name: string) => JSON.stringify({
        name: name,
        slug: name.toLowerCase().replace(/[^a-z0-9-]/g, '-'),
        version: '1.0.0',
        description: 'Plugin ' + name + ' generated by SaaS Plugin CLI',
        author: 'Plugin Developer',
        category: 'utility',
        tags: [name, 'plugin'],
        main: 'src/index.js',
        permissions: [],
        sandbox: { enabled: true, timeout: 30000 },
        config: {
          type: 'object',
          properties: {}
        }
      }, null, 2),
      
      'src/index.js': (name: string) => '/**\n' +
        ' * Plugin: ' + name + '\n' +
        ' * Basic plugin template for SaaS Boilerplate\n' +
        ' */\n\n' +
        '// Plugin lifecycle hooks\n' +
        'export async function initialize(context) {\n' +
        '  context.logger.info("Plugin ' + name + ' initialized")\n' +
        '}\n\n' +
        'export async function activate() {\n' +
        '  console.log("Plugin ' + name + ' activated")\n' +
        '}\n\n' +
        'export async function deactivate() {\n' +
        '  console.log("Plugin ' + name + ' deactivated")\n' +
        '}\n\n' +
        'export async function cleanup() {\n' +
        '  console.log("Plugin ' + name + ' cleaned up")\n' +
        '}\n\n' +
        '// Plugin exports\n' +
        'export const exports = {\n' +
        '  hello: () => "Hello from ' + name + ' plugin!",\n' +
        '  info: () => ({\n' +
        '    name: "' + name + '",\n' +
        '    version: "1.0.0",\n' +
        '    type: "basic"\n' +
        '  })\n' +
        '}\n\n' +
        'export default {\n' +
        '  initialize,\n' +
        '  activate,\n' +
        '  deactivate,\n' +
        '  cleanup,\n' +
        '  exports\n' +
        '}',
        
      'README.md': (name: string) => '# ' + name + ' Plugin\n\n' +
        'A basic plugin for the SaaS Boilerplate platform.\n\n' +
        '## Features\n\n' +
        '- Basic plugin structure\n' +
        '- Lifecycle hooks (initialize, activate, deactivate, cleanup)\n' +
        '- Simple exports\n\n' +
        '## Installation\n\n' +
        '1. Copy this plugin to your plugins directory\n' +
        '2. Run `saas-plugin install ' + name.toLowerCase() + '`\n' +
        '3. Configure and activate in the admin panel\n\n' +
        '## Development\n\n' +
        '```bash\n' +
        '# Watch for changes\n' +
        'saas-plugin dev ' + name.toLowerCase() + '\n\n' +
        '# Build plugin\n' +
        'saas-plugin build ' + name.toLowerCase() + '\n\n' +
        '# Test plugin\n' +
        'saas-plugin test ' + name.toLowerCase() + '\n' +
        '```\n\n' +
        '## Configuration\n\n' +
        'Add configuration options in the admin panel or via the plugin API.\n\n' +
        '## API Reference\n\n' +
        '### Exports\n\n' +
        '- `hello()`: Returns a greeting string\n' +
        '- `info()`: Returns plugin information\n\n' +
        '### Hooks\n\n' +
        '- `initialize(context)`: Called when plugin is initialized\n' +
        '- `activate()`: Called when plugin is activated\n' +
        '- `deactivate()`: Called when plugin is deactivated\n' +
        '- `cleanup()`: Called when plugin is cleaned up\n\n' +
        '## License\n\n' +
        'MIT\n',
      
      'package.json': (name: string) => JSON.stringify({
        name: name.toLowerCase().replace(/[^a-z0-9-]/g, '-'),
        version: '1.0.0',
        description: 'Plugin ' + name + ' for SaaS Boilerplate',
        main: 'src/index.js',
        scripts: {
          dev: 'saas-plugin dev',
          build: 'saas-plugin build',
          test: 'saas-plugin test',
          lint: 'saas-plugin lint'
        },
        keywords: ['saas', 'plugin', name.toLowerCase()],
        author: 'Plugin Developer',
        license: 'MIT'
      }, null, 2)
    }
  }
}

// =============================================================================
// COMMAND IMPLEMENTATIONS
// =============================================================================

/**
 * Create a new plugin
 */
async function createPlugin(pluginName: string, options: any) {
  try {
    const template = options.template || 'basic'
    const pluginPath = path.join(process.cwd(), 'plugins', pluginName)
    
    // Check if plugin already exists
    try {
      await fs.access(pluginPath)
      console.error('‚ùå Plugin \'' + pluginName + '\' already exists at ' + pluginPath)
      process.exit(1)
    } catch {
      // Directory doesn't exist, continue
    }
    
    // Create plugin directory
    await fs.mkdir(pluginPath, { recursive: true })
    
    // Get template
    const selectedTemplate = PLUGIN_TEMPLATES[template as keyof typeof PLUGIN_TEMPLATES]
    if (!selectedTemplate) {
      console.error('‚ùå Template \'' + template + '\' not found')
      console.log('Available templates:', Object.keys(PLUGIN_TEMPLATES))
      process.exit(1)
    }
    
    // Create files from template
    for (const [filename, templateFn] of Object.entries(selectedTemplate.files)) {
      const content = templateFn(pluginName)
      const filePath = path.join(pluginPath, filename)
      
      // Create directory if needed
      await fs.mkdir(path.dirname(filePath), { recursive: true })
      await fs.writeFile(filePath, content)
    }
    
    console.log('‚úÖ Plugin \'' + pluginName + '\' created successfully!')
    console.log('üìÅ Location: ' + pluginPath)
    console.log('üìã Template: ' + selectedTemplate.name)
    console.log('\nNext steps:')
    console.log('  cd plugins/' + pluginName)
    console.log('  saas-plugin dev')
    
  } catch (error) {
    console.error('‚ùå Failed to create plugin:', error.message)
    process.exit(1)
  }
}

/**
 * Install a plugin
 */
async function installPlugin(pluginPath: string) {
  try {
    console.log('üì¶ Installing plugin from: ' + pluginPath)
    
    // Check if plugin exists
    try {
      await fs.access(pluginPath)
    } catch {
      console.error('‚ùå Plugin not found at: ' + pluginPath)
      process.exit(1)
    }
    
    // Read manifest
    const manifestPath = path.join(pluginPath, 'plugin.json')
    let manifest
    
    try {
      const manifestContent = await fs.readFile(manifestPath, 'utf-8')
      manifest = JSON.parse(manifestContent)
    } catch {
      console.error('‚ùå Invalid plugin manifest at: ' + manifestPath)
      process.exit(1)
    }
    
    // Copy plugin to plugins directory
    const targetPath = path.join(process.cwd(), 'plugins', manifest.slug)
    await fs.mkdir(path.dirname(targetPath), { recursive: true })
    
    // Check if plugin already exists
    try {
      await fs.access(targetPath)
      console.log('‚ö†Ô∏è  Plugin already exists, updating...')
      await fs.rm(targetPath, { recursive: true, force: true })
    } catch {
      // Plugin doesn't exist, continue
    }
    
    await fs.cp(pluginPath, targetPath, { recursive: true })
    
    console.log('‚úÖ Plugin \'' + manifest.name + '\' installed successfully!')
    console.log('üìÅ Location: ' + targetPath)
    
  } catch (error) {
    console.error('‚ùå Failed to install plugin:', error.message)
    process.exit(1)
  }
}

/**
 * List installed plugins
 */
async function listPlugins() {
  try {
    const pluginsDir = path.join(process.cwd(), 'plugins')
    
    try {
      await fs.access(pluginsDir)
    } catch {
      console.log('üìÇ No plugins directory found')
      return
    }
    
    const entries = await fs.readdir(pluginsDir, { withFileTypes: true })
    const plugins = []
    
    for (const entry of entries) {
      if (entry.isDirectory()) {
        const manifestPath = path.join(pluginsDir, entry.name, 'plugin.json')
        
        try {
          const manifestContent = await fs.readFile(manifestPath, 'utf-8')
          const manifest = JSON.parse(manifestContent)
          plugins.push({
            name: manifest.name,
            slug: entry.name,
            version: manifest.version,
            description: manifest.description,
            author: manifest.author,
            category: manifest.category
          })
        } catch {
          plugins.push({
            name: entry.name,
            slug: entry.name,
            version: 'unknown',
            description: 'Invalid manifest',
            author: 'unknown',
            category: 'unknown'
          })
        }
      }
    }
    
    if (plugins.length === 0) {
      console.log('üìÇ No plugins installed')
      return
    }
    
    console.log('üìã Installed plugins:')
    console.log('')
    
    for (const plugin of plugins) {
      console.log('üîå ' + plugin.name + ' (' + plugin.slug + ')')
      console.log('   Version: ' + plugin.version)
      console.log('   Description: ' + plugin.description)
      console.log('   Author: ' + plugin.author)
      console.log('   Category: ' + plugin.category)
      console.log('')
    }
    
  } catch (error) {
    console.error('‚ùå Failed to list plugins:', error.message)
    process.exit(1)
  }
}

/**
 * Validate a plugin
 */
async function validatePlugin(pluginPath: string) {
  try {
    console.log('üîç Validating plugin: ' + pluginPath)
    
    const manifestPath = path.join(pluginPath, 'plugin.json')
    
    try {
      await fs.access(manifestPath)
    } catch {
      console.error('‚ùå Plugin manifest not found: ' + manifestPath)
      process.exit(1)
    }
    
    const manifestContent = await fs.readFile(manifestPath, 'utf-8')
    const manifest = JSON.parse(manifestContent)
    
    // Basic validation
    const errors = []
    const warnings = []
    
    if (!manifest.name) errors.push('Plugin name is required')
    if (!manifest.slug) errors.push('Plugin slug is required')
    if (!manifest.version) errors.push('Plugin version is required')
    if (!manifest.main) errors.push('Plugin main entry point is required')
    
    if (!manifest.description) warnings.push('Plugin description is recommended')
    if (!manifest.author) warnings.push('Plugin author is recommended')
    
    if (errors.length === 0) {
      console.log('‚úÖ Plugin validation passed')
      
      if (warnings.length > 0) {
        console.log('\n‚ö†Ô∏è  Warnings:')
        warnings.forEach(warning => console.log('   - ' + warning))
      }
    } else {
      console.log('‚ùå Plugin validation failed')
      console.log('\nüö´ Errors:')
      errors.forEach(error => console.log('   - ' + error))
      process.exit(1)
    }
    
  } catch (error) {
    console.error('‚ùå Failed to validate plugin:', error.message)
    process.exit(1)
  }
}

/**
 * Get plugin info
 */
async function infoPlugin(pluginPath: string) {
  try {
    const manifestPath = path.join(pluginPath, 'plugin.json')
    
    try {
      await fs.access(manifestPath)
    } catch {
      console.error('‚ùå Plugin manifest not found: ' + manifestPath)
      process.exit(1)
    }
    
    const manifestContent = await fs.readFile(manifestPath, 'utf-8')
    const manifest = JSON.parse(manifestContent)
    
    console.log('üìã Plugin Information:')
    console.log('Name: ' + manifest.name)
    console.log('Slug: ' + manifest.slug)
    console.log('Version: ' + manifest.version)
    console.log('Description: ' + manifest.description)
    console.log('Author: ' + manifest.author)
    console.log('Category: ' + manifest.category)
    console.log('Main: ' + manifest.main)
    
    if (manifest.dependencies && Object.keys(manifest.dependencies).length > 0) {
      console.log('Dependencies:')
      Object.entries(manifest.dependencies).forEach(([name, version]) => {
        console.log('  - ' + name + '@' + version)
      })
    }
    
    if (manifest.permissions && manifest.permissions.length > 0) {
      console.log('Permissions:')
      manifest.permissions.forEach((permission: any) => {
        console.log('  - ' + permission.resource + ': ' + permission.actions.join(', '))
      })
    }
    
  } catch (error) {
    console.error('‚ùå Failed to get plugin info:', error.message)
    process.exit(1)
  }
}

// =============================================================================
// CLI PROGRAM SETUP
// =============================================================================

// Parse command line arguments
const args = process.argv.slice(2)
const command = args[0]

if (!command) {
  console.log('SaaS Boilerplate Plugin CLI v' + CLI_CONFIG.version)
  console.log('')
  console.log('Usage: saas-plugin <command> [options]')
  console.log('')
  console.log('Commands:')
  console.log('  create <name>     Create a new plugin')
  console.log('  install <path>    Install a plugin from a local path')
  console.log('  list              List installed plugins')
  console.log('  validate <path>  Validate a plugin')
  console.log('  info <path>       Get plugin information')
  console.log('  templates         List available plugin templates')
  console.log('')
  console.log('Options:')
  console.log('  -t, --template <template>  Plugin template (basic)')
  process.exit(0)
}

switch (command) {
  case 'create':
    if (!args[1]) {
      console.error('‚ùå Plugin name is required')
      console.log('Usage: saas-plugin create <name> [options]')
      process.exit(1)
    }
    
    const options = {}
    for (let i = 2; i < args.length; i++) {
      if (args[i] === '-t' || args[i] === '--template') {
        if (i + 1 < args.length) {
          options.template = args[i + 1]
        }
      }
    }
    
    createPlugin(args[1], options)
    break
    
  case 'install':
    if (!args[1]) {
      console.error('‚ùå Plugin path is required')
      console.log('Usage: saas-plugin install <path>')
      process.exit(1)
    }
    installPlugin(args[1])
    break
    
  case 'list':
    listPlugins()
    break
    
  case 'validate':
    if (!args[1]) {
      console.error('‚ùå Plugin path is required')
      console.log('Usage: saas-plugin validate <path>')
      process.exit(1)
    }
    validatePlugin(args[1])
    break
    
  case 'info':
    if (!args[1]) {
      console.error('‚ùå Plugin path is required')
      console.log('Usage: saas-plugin info <path>')
      process.exit(1)
    }
    infoPlugin(args[1])
    break
    
  case 'templates':
    console.log('Available plugin templates:')
    Object.entries(PLUGIN_TEMPLATES).forEach(([key, template]) => {
      console.log('  ' + key + ' - ' + template.description)
    })
    break
    
  default:
    console.error('‚ùå Unknown command: ' + command)
    console.log('Run "saas-plugin" for help')
    process.exit(1)
}

// Handle uncaught errors
process.on('uncaughtException', (error) => {
  console.error('‚ùå Uncaught error:', error.message)
  process.exit(1)
})

process.on('unhandledRejection', (reason, promise) => {
  console.error('‚ùå Unhandled promise rejection:', reason)
  process.exit(1)
})